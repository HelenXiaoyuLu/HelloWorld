% This is the example of sp. 
% 
% Zhuohe Liu, St-Pierre Lab, Mar. 2020
% harry.liu@rice.edu

clear
% clear import
import sp.*

%% Phase 1: Import Files and Settings
lib = sp.libData('1P FieldStim');
lib.protocol.path = 'D:\OneDrive - rice.edu\Francois\RedGEVIs\Wet\Results\20190310-0318 Jun cp\20190308 200Hz';
lib.loadSet('path', '200Hz', ...
            'ch',1, ...
            'f',1:8, ...
            'ncpu', Inf);
lib.loadSet('path', 'brightness', ...
            'ch',1, ...
            'f',1:8, ...
            'asch', 2, ...
            'ncpu', Inf);
lib.regroup('method', 'perwell');          % regroup

% define calibration
lib.protocol.getChannel(1).binSize = 2;
lib.protocol.getChannel(2).binSize = 2;

% define stimulation
lib.protocol.setStimulation('path', 'MimicOldStim-20200323-173038.ams4100', ...
                            'separation', 0.1);

% temporal alignment
lib.getChildren('f').syncChannel('ch', 1);
return

%% Phase 2: Image Preprocessing
p = spcore.pipeline.pipeline('1P FieldStim');
p.addBlock(...
    'Name', 'Load Pixel', ...
    'operation', '@(I) I', ...
    'input', {{'I', {'rawFrames', 'C', 1}}, {'I', {'rawFrames', 'C', 2}}}, ...
    'output', {'I', {'raw', 'C', '', '', 'T', '', '', 'Z', '', ''}});
p.addBlock(...
    'Name', 'Saturation Mask (per channel)', ...
    'operation', '@(I, channel) channel.getSaturationMask(I)', ...
    'input', {{'I', {'raw', 'C', 1}, 'tag', {'raw', 'C', 1}}, ...
              {'I', {'raw', 'C', 2}, 'tag', {'raw', 'C', 2}}}, ...
    'output', {'I', {'satMaskCh', 'C', '', ''}});
p.addBlock(...
    'Name', 'Saturation Mask', ...
    'operation', '@(I) any(I, 3)', ...
    'input', {'I', {'satMaskCh', 'C', [], 'sparse', false}}, ...
    'output', {'I', {'satMask', 'C', 1, 1}});
p.addBlock(...
    'Name', 'Camera Calibration and Binning', ...
    'operation', '@(I, channel) channel.applyCorrection(I)', ...
    'input', {{'I', {'raw', 'C', 1}, 'tag', {'raw', 'C', 1}}, ...
              {'I', {'raw', 'C', 2}, 'tag', {'raw', 'C', 2}}}, ...
    'output', {'I', {'rawCalib', 'C', '', '', 'T', '', '', 'Z', '', ''}});
p.addBlock(...
    'Name', 'Temporal Alignment', ...
    'operation', "@(I, t, template) img.temporalAlignment(mean(I, 1:2), t, " + ...
        "'method', 'template', 'template', template, 'delayRange', [0, 0.8], 'figshow', true)", ...
    'input', {'I', {'rawCalib', 'C', 1}, 'tag', {'rawCalib', 'T', 'C', 1}, 'literal', lib.protocol.stimulation}, ...
    'output', {'data', 'alignment'}); 
p.addBlock(...
    'Name', 'Group Common Time Points', ...
    'operation', "@(t, dt) math.synchronize(t, 'dt', 0.01, 'offset', cell2mat(dt))", ...
    'input', {'tag', {'rawCalib', 'T', []}, 'data', 'alignment'}, ...
    'output', {'data', 't_common'}, ...
    'scalarSource', false);
p.addBlock(...
    'Name', 'Mean Reference', ...
    'operation', '@(I) mean(I, 4)', ...
    'input', {'I', {'rawCalib', 'C', 2}}, ...
    'output', {'I', {'meanRef', 'C', '', '', 'T', 1, 0, 'Z', '', ''}});
p.addBlock(...
    'Name', 'Background Correction Ref Channel', ...
    'operation', '@(I, M) img.bgcrt(I, img.bglevel(img.nanmasking(I, ~M), 16))', ...
    'input', {'I', {'meanRef', 'C', []}, 'I', {'satMask', 'C', []}}, ...
    'output', {'I', {'bgcrted', 'C', '', '', 'T', '', '', 'Z', '', ''}});
p.addBlock(...
    'Name', 'Background Correction Target Channel', ...
    'operation', '@(I, Iref, M) img.bgcrt(I, img.bglevel(img.nanmasking(Iref, ~M), 16))', ...
    'input', {'I', {'rawCalib', 'C', 1}, 'I', {'rawCalib', 'C', 1, 'T', 1}, 'I', {'satMask', 'C', []}}, ...
    'output', {'I', {'bgcrted', 'C', '', '', 'T', '', '', 'Z', '', ''}});
p.addBlock(...
    'Name', 'Resample Target Channel', ...
    'operation', "@(I, t, dt, tq) img.interpolate(I, {[], [], [], t' + dt}, {[], [], [], tq})", ...
    'input', {'I', {'bgcrted', 'C', 1}, 'tag', {'bgcrted', 'T', 'C', 1}, ...
              'data', 'alignment', 'data', 't_common'}, ...
    'output', {'I', {'resampled', 'C', '', '', 'T', [], '=4', 'Z', '', ''}});
p.addBlock(...
    'Name', 'Create Intensity Mask Ref Channel', ...
    'operation', '@(I) I > 80', ... 
    'input', {'I', {'bgcrted', 'C', 2}}, ...
    'output', {'I', {'refMask', 'C', '', ''}});
p.addBlock(...
    'Name', 'Final Mask', ...
    'operation', '@(M1, M2) ~M1 & M2', ... 
    'input', {'I', {'satMask', 'C', []}, 'I', {'refMask', 'C', []}}, ...
    'output', {'I', {'finalMask', 'C', 1, 1}});
p.addBlock(...
    'Name', 'Mask Target Channel', ...
    'operation', '@(I, M) img.nanmasking(I, ~M)', ...
    'input', {'I', {'resampled', 'C', 1}, 'I', {'finalMask', 'C', 1}}, ...
    'output', {'I', {'masked', 'C', '', '', 'T', '', '', 'Z', '', ''}});

%% Phase 3: Define Quantifications
workspace = lib.protocol.workspace;
workspace.deleteMetric();

workspace.addMetric("group g");

workspace.addMetric("trace(g) = reshape(nanmean(g.getChildren('f').getImageSet('name', 'masked').getPixel('F', [], 'C', 1), 1:3), [], 1)");
workspace.addMetric("trace_t(g) = reshape(g.getChildren('f',1).getImageSet('name', 'masked').getTag('T', 'T', []), [], 1)");
workspace.addMetric("delta_t(g) = arrayfun(@(x) x.Data.alignment, g.getChildren('f'))");
workspace.addMetric("refF0(g) = nanmean(img.nanmasking(g.getChildren('f').getImageSet('name', 'bgcrted').getPixel('F', [], 'C', 2), " + ...
    "g.getChildren('f').getImageSet('name', 'finalMask').getPixel()), 1:3)");
workspace.addMetric("refF0Map(g) = g.getChildren('f').getImageSet('name', 'bgcrted').getPixel('F', [], 'C', 2)");
workspace.addMetric("mask(g) = g.getChildren('f').getImageSet('name', 'finalMask').getPixel('F', [])");

%% Phase 4: Non-parallel Processing
g = lib.getChildren('g');
result = cell(numel(g), 1);
wb = ui.progressBar([]);
for i = 1:numel(g)
    % generate task specific to current group
    p.getChildren('b').recreate('source', g(i).getChildren('f'));
    % execute tasks
    p.getChildren('t').execute();
    % calculating metrics
    result{i} = workspace{'trace', 'trace_t', 'delta_t', 'refF0', ...
        'refF0Map', 'mask'}.autoEval(g(i));
    %result{i} = workspace{'trace', 'trace_t'}.autoEval(g(i));
    % unexecute to release memory
    p.getChildren('t').unexecute();
    ui.progressBar([i, numel(g)], 'Overall Process (FOV)', wb);
end
delete(wb); % close progress bar
result = cat(1, result{:}); % concatenating to one table

figure(1) % show masks
subplot(2,2,1)
msk = result.mask{1,1} ;
imshow(msk(:,:,1),[])
subplot(2,2,2)
imshow(msk(:,:,2),[])
subplot(2,2,3)
imshow(msk(:,:,3),[])
subplot(2,2,4)
imshow(msk(:,:,4),[])
figure(2)
plot(result.trace_t{1,1},result.trace{1,1})
%% Phase 4: Parallel Processing
% prepare data to be sent to parallel workers
g = lib.getChildren('g').getBranch();       % split groups
libRoot = lib.getOrphan();                  % clone orphaned library
libRoot.protocol = lib.protocol.getDecoupledProtocol(libRoot);
result = cell(numel(g), 1);                 % calculation result
% Data into parallel: g, p, libRoot
tic;
ticBytes(gcp);
parfor i = 1:1  %lib.n
    % reconstruct library
    g(i).setParent(libRoot);
    % generate task specific to current group
    p.getChildren('b').recreate('source', g(i).getChildren('f'));
    % execute pipeline
    p.getChildren('t').execute();
    % calculating metrics
    workspace = libRoot.protocol.workspace;
    result{i, 1} = workspace{'trace', 'trace_t', 'delta_t', 'refF0', ...
        'refF0Map', 'mask'}.autoEval(g(i));
end
tocBytes(gcp);
toc;
result = cat(1, result{:});         % convert cell to struct