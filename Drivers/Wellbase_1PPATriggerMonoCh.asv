function [T_group, T_well, T_fov] = Wellbase_1PPATriggerMonoCh(cfg)
    % Wellbase_1PFieldStimTrigger is a pipeline main function. 
    % [T_group, T_well, T_fov] = Wellbase_1PFieldStimTrigger(cfg)
    % INPUT
    %   cfg (optional): job configuration object. Default, test dataset is used. 
    %       See the source code for default values. 
    % OUTPUT
    %   T_group, T_well, T_fov: result tables. 
    % 
    % Zhuohe Liu, St-Pierre Lab, June 2020
    % harry.liu@rice.edu
    
    arguments
        cfg (1,1) db.jobConfig = db.jobConfig()
    end
    
    % Default Inputs
    cfg.default = db.jobConfig(...
        'path', 'D:\OneDrive - rice.edu\Francois\ASAPScreening\Wet\Data\20200710 JEDI photoactivation', ...
        'tgtCh\path', 'TrainStim 10pct violet JEDI monoch', ...
        'stim', 'PA train-20200708-162342.ams4100');
    
    %% Phase 1: Import Files and Settings
    lib = sp.libData('1P Triggered photoactivation');
    lib.protocol.path = cfg.getConfig('path');
    lib.loadFrame(...
        'path', cfg.getConfig('tgtCh\path'), ...
        'ch', 1);
    lib.loadFOV();
    lib.regroup('method', 'perwell');      % regroup

    % define calibration
    lib.protocol.getChannel(1).binSize = 2;

    % define stimulation from file
    lib.protocol.setStimulation('path', cfg.getConfig('stim'), ...
                                'separation', 0.1);
%     %% Phase 1 (default): Import Files and Settings
%     lib = sp.libData('1P Triggered photoactivation');
%     lib.protocol.path = cfg.default.getConfig('path');
%     lib.loadFrame(...
%         'path', cfg.default.getConfig('tgtCh\path'), ...
%         'ch', 1);
%     lib.loadFOV();
%     lib.regroup('method', 'perwell');      % regroup
% 
%     % define calibration
%     lib.protocol.getChannel(1).binSize = 2;
% 
%     % define stimulation from file
%     lib.protocol.setStimulation('path', cfg.default.getConfig('stim'), ...
%                                 'separation', 0.1);
    %% Phase 2: Image Processing
    T = lib.getChildren('f',1).nt; % last frame
    p = spcore.pipeline.pipeline('1P FieldStim');
    p.Base = lib;
    p.addBlock(...
        'Name', 'Load Pixel', ...
        'operation', '@(I) I', ...
        'source', {':', ':', ':'}, ...
        'input', {'I', {'rawFrames', 'C', 1}}, ...
        'output', {'I', {'raw', 'C', '', '', 'T', '', '', 'Z', '', ''}});
    p.addBlock(...
        'Name', 'Saturation Mask', ...
        'operation', '@(I, channel) channel.getSaturationMask(I)', ...
        'source', {':', ':', ':'}, ...
        'input', {'I', {'raw', 'C', 1}, 'tag', {'raw', 'C', 1}}, ...
        'output', {'data', 'satMask'});
    p.addBlock(...
        'Name', 'Camera Calibration and Binning', ...
        'operation', '@(I, channel) channel.applyCorrection(I)', ...
        'source', {':', ':', ':'}, ...
        'input', {'I', {'raw', 'C', 1}, 'tag', {'raw', 'C', 1}}, ...
        'output', {'I', {'rawCalib', 'C', '', '', 'T', '', '', 'Z', '', ''}});
    p.addBlock(...
        'Name', 'Background Correction Target Channel', ... % using last frame
        'operation', '@(I, M) img.bgcrt(I, img.bglevel(img.nanmasking(I, ~M), 16))', ...
        'source', {':', ':', ':'}, ...
        'input', {'I', {'rawCalib', 'C', 1}, 'data', 'satMask'}, ...
        'output', {'I', {'bgcrted', 'C', '', '', 'T', '', '', 'Z', '', ''}});
    p.addBlock(...
        'Name', 'Exampler Frame', ...
        'operation', '@(I) I', ...
        'source', {':', ':', ':'}, ...
        'input', {'I', {'bgcrted', 'C', 1, 'T', T}}, ...
        'output', {'data', 'RMap'});
    p.addBlock(...
        'Name', 'Final Mask', ...
        'operation', '@(M1, I) ~M1 & I >= 250', ... 
        'source', {':', ':', ':'}, ...
        'input', {'data', 'satMask', 'I', {'bgcrted', 'C', 1, 'T', T}}, ...
        'output', {'data', 'finalMask'});
    p.addBlock(...
        'Name', 'Trace', ...
        'operation', "@(I, M) img.groupfun(I, M, @nanmean, 'toCell', true, 'ignoreGroup', 0)", ... 
        'source', {':', ':', ':'}, ...
        'input', {'I', {'bgcrted', 'C', 1}, 'data', 'finalMask'}, ...
        'output', {'data', 'trace', 'omit', [], 'data', 'Area'});
    p.addBlock(...
        'Name', 'Trace Time', ...
        'operation', '@(t) t', ...
        'source', {':', ':', ':'}, ...
        'input', {'tag', {'bgcrted', 'T', 'C', 1}}, ...
        'output', {'data', 'trace_t'});
    
    % execute tasks
    p.getChildren('t').execute('ncpu', Inf);
    
    %% Phase 3: Export Result
    % data is saved at p.dataStore
    % You can genenrate report of ROI quantifications
    f = lib.getChildren('f');
    T_fovData = p.dataStore.report(f);
    % generate FOV descriptor
    T_fov = table(cat(1, f.getParent().UID), ...
        cat(1, f.UID), ...
        string({f.Name})', ...
        arrayfun(@(fov) fov.frame(1).image(1).file.path, f), ...        
        'VariableNames', ["Well", "FOV", "Name", "Path"]);
    T_fov = cat(2, T_fov, T_fovData);
    
    % create sig objects
    traceRaw = sig.arbitrary.empty();
    for i = 1:numel(f)
        s = sig.arbitrary();
        s.setSignal(T_fov.trace_t{i}, T_fov.trace{i});
        traceRaw(i, 1) = s;
    end
    T_fov.trace_t = [];
    T_fov.trace = [];
    T_fov.TraceRaw = traceRaw;
    
    % generate well descriptor
    w = lib.getChildren('w');
    T_well = table(cat(1, w.getParent().UID), ...
        cat(1, w.UID), ...
        string({w.Name})', ...
        string({w.wellName})', ...
        arrayfun(@(w) w.plate.ID, w), ...
        'VariableNames', ["Group", "Well", "Name", "wellName", "plateID"]);
    
    % generate group descriptor
    g = lib.getChildren('g');
    T_group = table(cat(1, g.UID), ...
        string({g.Name})', ...
        'VariableNames', ["Group", "Name"]);
    
    % stimulation
    stim = lib.protocol.stimulation;
    sevents = stim.segment(0.1);
    seventRange = sevents.range();
    
    %% Phase 4: Trace Analysis
    % align using template, detrend and normalize
    n_fov = numel(f);
    traces = sig.arbitrary.empty();
    delay = zeros(n_fov, 1);
    pb = ui.progressBar(n_fov);
    for i = 1:n_fov
        s = T_fov.TraceRaw(i).copy();
        % time alignment
        delay(i) = img.temporalAlignment(s.y, s.x, 'method', 'excitation', 'figshow', false);
        s.lag(delay(i));
        % crop initial no excitation region
        s.crop(0.5);
        % detrend (remove response region)
        idleIdx = seventRange.t2v(s.x) == 0;
        Fd = img.detrend(s.y, 1, s.x, 'order', 3, 'figshow', false, ...
            'method', 'div', 'idleIdx', idleIdx);       
        % normalize
        Ffinal = math.normbase(Fd, 1:100, 1);
        s.setSignal(s.x, Ffinal);
        traces(i, 1) = s;
        pb.increment();         % increment progress
    end
    T_fov.Delay = delay;
    T_fov.TraceDetrend = traces;

    % resample
    T_fov.TraceFinal = T_fov.TraceDetrend;
    T_fov.TraceFinal = T_fov.TraceFinal.synchronize('dt', 0.001, 'method', 'intersect');
 
    % well lvl stats
    wellgroups = findgroups(T_fov.Well);
    T_well.Area = splitapply(@sum, T_fov.Area, wellgroups);
    T_well.TraceRaw = splitapply(@mean, T_fov.TraceRaw, T_fov.Area, wellgroups);
    T_well.TraceDetrend = splitapply(@mean, T_fov.TraceDetrend, T_fov.Area, wellgroups);
    T_well.TraceFinal = splitapply(@mean, T_fov.TraceFinal, T_fov.Area, wellgroups);
   
    % group lvl stats
    groupgroups = findgroups(T_well.Name);
    T_group.Area = splitapply(@mean, T_well.Area, wellgroups);
    T_group.TraceRaw = splitapply(@mean, T_well.TraceRaw, T_fov.Area, wellgroups);
    T_group.TraceDetrend = splitapply(@mean, T_fov.TraceDetrend, T_fov.Area, wellgroups);
    T_group.TraceFinal = splitapply(@mean, T_fov.TraceFinal, T_fov.Area, wellgroups);    
end